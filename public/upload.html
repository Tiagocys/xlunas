<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enviar conteúdo • Xlunas</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <main class="card" style="max-width:600px">
    <h1>Enviar vídeo ou foto</h1>

    <form id="uploadForm">
      <label>Arquivo (MP4, MOV, JPG, PNG)
        <input type="file" id="fileInput" accept="video/*,image/*" required />
      </label>

      <label>Thumbnail (opcional)
        <input type="file" id="thumbInput" accept="image/*" />
      </label>

      <label>Título
        <input type="text" id="title" maxlength="120" required />
      </label>

      <label>Descrição (opcional)
        <textarea id="description" maxlength="500" rows="3"></textarea>
      </label>

      <button type="submit" id="sendBtn">Enviar</button>
      <progress id="progress" value="0" max="100" hidden></progress>
      <p id="msg" class="msg"></p>
    </form>
  </main>

  <script type="module">
    import { supabase } from './supabase.js';

    const form       = document.getElementById('uploadForm');
    const fileInput  = document.getElementById('fileInput');
    const thumbInput = document.getElementById('thumbInput');
    const titleInput = document.getElementById('title');
    const descInput  = document.getElementById('description');
    const progress   = document.getElementById('progress');
    const msgP       = document.getElementById('msg');
    const sendBtn = document.getElementById('sendBtn');

    // 1) Novo extractFrame, garantindo que onloadedmetadata seja definido antes do src
    async function extractFrame(file) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';

        video.onloadedmetadata = () => {
          URL.revokeObjectURL(video.src);
          // seek para o meio do vídeo (ou 1s se curto)
          const seekTime = Math.min(1, video.duration / 2);
          video.currentTime = seekTime;
        };

        video.onseeked = () => {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          canvas.toBlob((blob) => {
            if (blob) {
              resolve(new File([blob], 'thumbnail.png', { type: 'image/png' }));
            } else {
              reject(new Error('Não foi possível gerar o blob do canvas'));
            }
          }, 'image/png');
        };

        video.onerror = () => reject(new Error('Erro ao carregar o vídeo para gerar thumbnail'));
        video.src = URL.createObjectURL(file);
        video.load();
      });
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      sendBtn.disabled = true;          // <─ trava logo no primeiro clique
      sendBtn.textContent = 'Enviando...'
      sendBtn.style.backgroundColor = "#ff7575";
      msgP.textContent = '';
      const file = fileInput.files[0];
      if (!file) return;

      // 1) Verifica sessão e plano
      const { data: { session }, error: sessErr } = await supabase.auth.getSession();
      if (sessErr || !session) {
        msgP.textContent = 'Sessão expirada. Faça login novamente.';
        return;
      }
      const userId = session.user.id;
      const { data: userData, error: userErr } = await supabase
        .from('users')
        .select('plan')
        .eq('id', userId)
        .single();
      if (userErr) {
        msgP.textContent = 'Erro ao verificar plano.';
        return;
      }
      const plan = userData.plan;

      // 2) Free: checa limites diários via duração de vídeo
      const isVideo = file.type.startsWith('video/');
      let durationMins = 0;
      if (plan === 'free' && isVideo) {
        durationMins = await new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.src = URL.createObjectURL(file);
          v.onloadedmetadata = () => {
            URL.revokeObjectURL(v.src);
            resolve(Math.ceil(v.duration / 60));
          };
        });
        if (durationMins > 5) {
          msgP.textContent = 'No plano Free, máximo de 5 min por vídeo.';
          return;
        }
        const { data: allowed, error: quotaErr } = await supabase.rpc('check_and_increment_usage', {
          p_user: userId,
          p_minutes: durationMins
        });
        if (quotaErr) {
          msgP.textContent = 'Erro ao verificar cota.';
          return;
        }
        if (!allowed) {
          msgP.textContent = 'Limite diário atingido: 1 vídeo ou 5 min.';
          return;
        }
      }

      // 3) Upload de thumbnail (após extrair ou ler do input)
      let thumbUrl = null;
      try {
        const thumbFile = thumbInput.files[0] ?? await extractFrame(file);
        // faça o upload para o bucket “thumbnails”
        const thumbPath = `thumbnails/${userId}/${Date.now()}.png`;
        const { data: thumbData, error: thumbErr } = await supabase
          .storage
          .from('thumbnails')
          .upload(thumbPath, thumbFile, { cacheControl: '3600', upsert: false });

        if (thumbErr) throw thumbErr;
        const { data: { publicUrl } } = supabase
          .storage
          .from('thumbnails')
          .getPublicUrl(thumbPath);
        thumbUrl = publicUrl;
      } catch (err) {
        console.error('Erro no upload da thumbnail:', err);
        // segue em frente sem thumbnail
      }


      // 4) Solicita uploadURL e uid ao Worker
      const endpoint = isVideo
        ? 'https://x-lunas.cysneirostiago.workers.dev/stream-direct-upload'
        : '/image-direct-upload';
      const tokenRes = await fetch(endpoint, { method: 'POST' });
      if (!tokenRes.ok) {
        msgP.textContent = 'Erro ao gerar token.';
        return;
      }
      const { uploadURL, uid } = await tokenRes.json();

      // 5) Upload via XHR
      progress.hidden = false;
      const xhr = new XMLHttpRequest();
      xhr.open('POST', uploadURL);
      xhr.upload.onprogress = (ev) => {
        if (ev.lengthComputable) {
          progress.value = ((ev.loaded / ev.total) * 100).toFixed(2);
        }
      };
      xhr.onload = async () => {
        if (xhr.status !== 200) {
          msgP.textContent = `Falha no upload: ${xhr.status}`;
          progress.hidden = true;
          sendBtn.disabled = false;         // <─ libera de novo
          sendBtn.textContent = "Enviar";
          return;
        }
        progress.value = 100;
        // 6) Grava metadados em Supabase
        const mediaType = isVideo ? 'video' : 'image';
        const mediaUrl  = isVideo ? uid : uploadURL;
        const { error } = await supabase
          .from('posts')
          .insert({
            creator_id   : userId,
            media_url    : mediaUrl,
            media_type   : mediaType,
            title        : titleInput.value.trim(),
            description  : descInput.value.trim(),
            thumbnail_url: thumbUrl,
            is_private   : true
          });
        if (error) msgP.textContent = error.message;
        else {
          msgP.textContent = 'Upload concluído!';
          form.reset();
        }
        progress.hidden = true;
        sendBtn.disabled = false;         // <─ libera de novo
        sendBtn.textContent = "Enviar";
      };
      xhr.onerror = () => {
        msgP.textContent = 'Erro de rede.';
        progress.hidden = true;
        sendBtn.disabled = false;         // <─ libera de novo
        sendBtn.textContent = "Enviar";
      };
      const formData = new FormData();
      formData.append('file', file);
      xhr.send(formData);
    });
  </script>
</body>
</html>